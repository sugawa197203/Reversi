# MCC Git-C 言語講座 2

今回は Git を使って C言語 でリバーシプログラムを作ります。GIt が長くなったのでリバーシだけこっちにしました。

## リポジトリのクローン

まずこのリポジトリをクローンしましょう。

## WSL で開く(Mac の人はやらなくていいです)

Ctrl + P (Mac はたぶん Command + P) でコマンドパレットを開きます。

`> wsl` と打って出てきた `WSL でフォルダーをもう一度開く...` を選択してください。

![openwsl](./resources/openwsl.png)

WSL でウィンドウを開いたら VS Code の拡張機能の Git Graoh と Git History を WSL 用に入れてください。入れ直さないといけないみたいです。

![gitinstall](./resources/gitinstall.png)

最初から WSL でやれよ！とか言わないでください。 Windows でも Git の環境作ったほうが将来的に便利ですよ！！！

* メアドと名前設定

ここでも Github のダミーメアドとユーザーネームを使います。WSL でもメアドと名前のコマンドは同じです。

```
git config --global user.email メールアドレス
```
```
git config --global user.name ユーザー名
```

## ncurses

リバーシの盤面を表示するために ncurses というライブラリを使います。はじめに ncurses についてちょっとだけサクッと説明します。ncursesとはコンソールで、キーの入力、マウスイベント処理、色付きで画面表示などを行うためのテキストユーザーインターフェース (TUI) のライブラリです。 (部長のMacでは動作確認できたけど他の人ワンチできないかもしれない)

### ncurses で Helloworld

とりあえず、ncurses で Hello World を表示するサンプルコードをためしてみましょう。 `ncurses_sample.c` に書き込んでください。

`#include <ncurses.h>` を忘れないで下さい。

```c
#include <ncurses.h>

int main(void)
{
	initscr();	// ncurses の初期化

	printw("Hello World!");
	move(5, 10);
	printw("Moved!");
	mvprintw(10, 20, "Moved more!");

	refresh();	// 画面の更新
	getch();	// キー入力
	endwin();	// ncurses の終了
}
```

コンパイルオプションを忘れないで下さい。 (math.h を include するときみたいな感じ)

```
gcc ncurses.c -lncurses
```

* `initscr` , `endwin` 関数

`initscr` 関数で、コンソールが ncurses 用のコンソールに切り替わります。 `initscr` 関数を呼び出したら、最後に `endwin` 関数を読んでから終了して下さい。そうしないとコンソールがバグります。

* `printw` 関数

`printw` 関数は、文字を出力します。 ncurses 用のコンソールに切り替わったとき、はじめカーソルは左上にあるため、文字は左上に表示されます。文字を出力した分だけカーソルは右に移動します。

* `move` 関数

`move` 関数は、カーソルを移動します。 `move(5, 10)` とすると、カーソルは 5 行目 10 列目に移動します。

* `mvprintw` 関数

`mvprintw` 関数は、`move` 関数と `printw` 関数を合わせた関数です。 `mvprintw(10, 20, "Moved more!")` とすると、カーソルは 10 行目 20 列目に移動して、文字を表示します。

![nc1](./resources/nc1.png)

* `fresh` マクロ

`fresh` マクロは、画面を更新します。 `printw` マクロで文字を表示したときは、画面に表示されません(環境と場合による)。 `fresh` マクロを呼び出すと、画面に表示されます。

* `getch` マクロ

`getch` マクロは、キー入力を待ちます。 呼び出すと、キー入力を待ちます。キー入力があると、そのキーのキーコードが返ります。キー入力が来るまで、プログラムは止まります。マウスのクリック、スクロールもキー入力として扱われます。

### ncurses で色をつける

先程作ったサンプルコードを書換えます。

```c
#include <ncurses.h>

int main(void)
{
	initscr();

	start_color();
	init_pair(1, COLOR_BLACK, COLOR_WHITE); // 黒文字、白背景
	init_pair(2, COLOR_WHITE, COLOR_RED);	// 白文字、赤背景
	init_pair(3, COLOR_CYAN, COLOR_BLUE);	// 水色文字、青背景

	bkgd(COLOR_PAIR(1)); // 背景色を設定

	printw("Hello World!");
	move(5, 10);

	attrset(COLOR_PAIR(2)); // 文字色を設定
	printw("Moved!");

	attrset(COLOR_PAIR(3)); // 文字色を設定
	mvprintw(10, 20, "Moved more!");

	refresh();
	getch();
	endwin();
}
```

* `start_color` 関数

`start_color` 関数は、色を使うための初期化関数です。 `start_color` 関数を呼び出さないと、色を使えません。

* `init_pair` 関数

`init_pair` 関数は、色を設定します。第1引数に色の番号を指定します。第2引数に文字色、第3引数に背景色を指定します。パレットの番号に色を設定している感じです。

上のコードでは、`黒文字、白背景` と、 `白文字、赤背景` と、 `水色文字、青背景`を設定しました。

* `bkgd` マクロ

`bkgd` マクロは、背景色を設定します。 `bkgd(COLOR_PAIR(1))` とすると、デフォルトの背景色が `init_pair` で `1` に設定した `黒文字、白背景` になります。 `COLOR_PAIR(2)` にすると、背景色が `白文字、赤背景` になります。

* `attrset` マクロ

`attrset` マクロは、文字色と背景色を設定します。 `attrset(COLOR_PAIR(2))` とすると、次以降呼び出されるPrint系の文字色が `init_pair` で `2` に設定した `白文字、赤背景` になります。 `COLOR_PAIR(3)` にすると、文字色が `水色文字、青背景` になります。

![nc2](./resources/nc2.png)

`bkgr` でデフォルトの背景色が `黒文字、白背景` になったので、背景が真っ白で、 `Hello World!` は `黒文字` で表示されました。 `Moded!` と `Moved more!` は先程指定した `2` と `3` の色になりました。

### マウスの取得

マウスでコンソールをクリックして、クリックした場所を取得してみましょう。下記のコードは、クリックした場所に `*` を表示し、その座標も表示します。座標はコンソールの文字の座標です。 `q` キーで終了します。

```c
#include <ncurses.h>

int main(void)
{
	initscr();

	noecho();						   // 入力された文字を表示しない
	curs_set(0);					   // カーソルを非表示
	keypad(stdscr, TRUE);			   // マウスイベントの取得に必要
	mousemask(ALL_MOUSE_EVENTS, NULL); // マウスイベントを取得

	MEVENT event;
	int ch;
	int x, y;

	while ((ch = getch()) != 'q')
	{
		if (ch != KEY_MOUSE)
			continue;

		if (getmouse(&event) == OK)
		{
			x = event.x;
			y = event.y;

			mvprintw(0, 0, "x: %d, y: %d  ", x, y);
			mvprintw(y, x, "*");
		}

	}

	refresh();
	endwin();
}
```

* `noecho` 関数

`noecho` 関数は、入力された文字を表示しないようにします。 この関数の部分をコメントアウトすると、 `q` キー以外を押したとき、その文字がコンソールに出てきます。

* `curs_set` 関数

`curs_set` 関数は、カーソルを表示するかどうかを設定します。 `0` にすると、カーソルが非表示になります。

* `keypad` 関数

`keypad` 関数は、キーパッドを使うかどうかを設定します。 `TRUE` にすると、キーパッドを使えるようになります。マウスイベントを取得するために必要です。

* `mousemask` 関数

`mousemask` 関数は、マウスイベントを取得するために必要です。 `ALL_MOUSE_EVENTS` にすると、マウスの全てのイベントを取得できます。

* `getmouse` 関数

`getmouse` 関数は、マウスのイベントを取得します。 `MEVENT` 構造体にイベントの情報が格納されます。

* `MEVENT` 構造体

`MEVENT` 構造体は、マウスのイベントの情報を格納する構造体です。 `x` と `y` には、コンソールの文字の座標が格納されます。

![nc3](./resources/nc3.png)


## リバーシプログラムの概要

サクッと盤面の表示に使う ncurses について触れました。ここからリバーシを作っていきます。

### ビットボード

今回のリバーシでは、盤面を表すのに、 **ビットボード** と言うものを使っています。ビットボードとは整数型の変数を 2 進数で扱って、盤面の状態を表す方法です。今回は 8x8 の盤面を表すので、64bit の変数を使って、盤面の状態を表します。白黒それぞれでビットボードを用意して、盤面の状態を表します。

* 石がある場所を求める

白か黒、どちらかがある盤面は、白と黒のビットボードの積で求められます。

![bitboard1](./resources/bitboard1.png)

* 盤面のシフト

ある場所の石を 8 近傍にずらすには**シフト**することで実現できます。シフトとは、ビット列を左右にずらすことです。C言語では `<<` で左シフト、`>>` で右シフトができます。

![bitsift](./resources/bitsift.png)

* ビットを数える処理 (popcount)

盤にある石の数は、ビットボードで立っているビットの数を数えれることで求められます。立っているビットを数える方法としてビットボードを細かく分けて数えてく分割統治法で求めます。以下の画像は 2bit のうち、立っている bit を数える過程で、 2 bit の全パターンを示しています。

|2bit (x)|x >> 1|(x >> 1) & 0b01|x - (x >> 1) & 0b01|左のやつを10進数|
|:---:|:---:|:---:|:---:|:---:|
|00|00|00|00|0|
|01|00|00|01|1|
|10|01|01|01|1|
|11|01|01|10|2|

2 bit で立っている bit の数を数えてたら、 4 bit で立っている数を数えます。最後に 4 bit で立ってるビットの数 3 になると思います。

1. 立ってる個数を求めたい 4 bit
```
0111
```
2. 左右 2 bit で立っている数を求める。 左が 01 で 1 で右が 11 で 2 になっているのがわかる。
```
0110
```
3. 2 bit 右にシフト
```
0001
```
4. 2 のやつにマスクをかける
```
0110 & 0011 = 0010
```
5. 3 のやつ + 4 のやつ
```
0001 + 0010 = 0011
```

4 bit で立っている bit の数を数えてたら、 4 bit で立っている数を数えます。

1. 4 bit のやつの 5 の続き。 左 4 bit に `0001` があることを想定(左 4 bit で立ってる数は 1 つだけ)。
```
0001 0011
```
2. マスクを追加
```
0001 0011 & 0000 1111 = 0000 0011
```
3. 1 のやつを 4 bit 右シフト
```
0000 0001
```
4. 2 のやつ + 3 のやつ
```
0000 0011 + 0000 0001 = 0000 0100
```

結果は 4 になりました。右側 4 bit は 3 つ、左側 4 bit は 1 つ立っているので、 4 が正しいことがわかります。


```
sudo apt-get install libncurses5-dev libncursesw5-dev ncurses-doc
```